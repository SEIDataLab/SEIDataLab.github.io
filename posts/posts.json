[
  {
    "path": "posts/parquet_com_R/",
    "title": "Parquet para grandes conjuntos de dados no R",
    "description": "Apesar do formato csv ser largamente adotado, quando o conjuntos de dados é grande, o csv apresenta limitações. Nesses casos, pode ser vantajoso optar pelo Parquet, um  formato de arquivo para armazenamento de dados orientado a colunas. Abordamos aqui a performance de arquivos Parquet no R através da biblioteca Arrow da Apache Foundation. Foi utilizado como exemplos os microdados do Censo Escolar 2019, disponibilizados pelo INEP - Ministério da Educação do Brasil.",
    "author": [
      {
        "name": "Jonatas Silva do Espirito Santo",
        "url": "https://github.com/jonates/"
      }
    ],
    "date": "2021-02-15",
    "categories": [],
    "contents": "\r\n\r\nbody {\r\ntext-align: justify}\r\nJá se passaram décadas após a criação do csv, mas ainda é rotina entre as intituições, seja no setor privado, seja nas instituições públicas, armazenar dados em um arquivo csv (“comma-separated-values”), que como próprio significado da sigla já diz, é um arquivo com valores separados por vírgulas. Vale ressaltar que, como no Brasil a vírgula é utilizada como separador de casa decimal, então é prática comum utilizar o sinal ponto e vírgula (;) como separador de valores, em vez de usar o sinal vírgula. Também, pode-se utilizar outro caractere como separador de colunas, e, assim o csv passa a ser chamado por alguns como “character-separated-values”.\r\nA maioria dos softwares e aplicativos tem suporte para leitura e gravação de arquivos csv, pois este é um formato de arquivo bastante difundido e de fácil manipulação (a depender do tamanho do arquivo, é possível abrir em um bloco de notas, fazer uma leitura humana, e inclusive editar o arquivo de dados csv).\r\nNo csv, cada linha representa um registro, e os valores dos campos associados a esses registros são separados por vírgula (ou ponto e vírgula ou outro caractere). Por exemplo, suponha que seja de interesse, armazenar em um arquivo csv com informações básicas das últimas 5 copas do mundo de futebol masculino da FIFA. Para tanto, bastaria abrir um bloco de notas, digitar o texto abaixo e depois salvar com a extensão .csv:\r\nsede,campeão,ano\r\nRússia,França,2018\r\nBrasil,Alemanha,2014\r\nÁfrica do Sul,Espanha,2010\r\nAlemanha,Itália,2006\r\nCoréia do Sul e Japão,Brasil,2002\r\n\r\nPorém, apesar das diversas vantagens, quando o número de registros e de campos aumentam de forma considerável, a leitura desses arquivos passam a ter custo computacional elevado, pois o csv é um arquivo “row oriented dataset” (ou ainda chamado também de “row storage”), ou seja, como o próprio nome define, é um conjunto de dados orientados a linha, e assim, a leitura do arquivo é feito linha a linha. Portanto, mesmo que o interesse de análise seja de uma ou de algumas colunas específicas, todas as colunas serão lidas, diminuindo assim a performance.\r\nEntão, o formato de arquivos Apache parquet, que é um “column oriented dataset”, ou seja, conjunto de dados orientado a colunas, se torna uma excelente alternativa ao .csv para gravar grandes conjuntos de dados para análise, pois, além de leitura mais rápida, a taxa de compressão desses arquivos é muito maior em relação aos .csv ocupando menos espaço em disco.\r\nDe acordo com o site do projeto (https://parquet.apache.org/): “Apache Parquet is a columnar storage format available to any project in the Hadoop ecosystem, regardless of the choice of data processing framework, data model or programming language”, ou seja, é um formato de armazenamento colunar, disponível para qualquer projeto do ecossistema Hadoop, independente da escolha da estrutura de processamento dos dados, do modelo dos dados ou da linguagem de progamação.\r\nO conjunto de dados de exemplo\r\nVamos utilizar como exemplo, dados do censo escolar 2019, realizado pelo Ministério da Educação do Brasil. Os microdados, são disponibilizados para download no site do INEP - Instituto Nacional de Estudos e Pesquisas Educacionais Anísio Teixeira.\r\nO download é de um arquivo microdados_educacao_basica_2019 compactado com extensão .zip, cujo conteúdo é uma pasta microdados_educacao_basica_2019 contendo quatro outras pastas ANEXOS, DADOS, FILTROS, LEIA-ME.\r\nNa pasta DADOS existem 15 conjuntos de dados em formato .csv.\r\nEsses conjuntos de dados são relativamente massivos. Por exemplo, o arquivo MATRICULA_NORDESTE.CSV que é o conjunto de dados com informações de cada aluno matriculado na educação básica em escolas do Nordeste do Brasil, possui 15.304.589 registros e 103 campos, e, ocupa em disco 3.790.278 KB, ou seja quase 3,8 Gigabytes.\r\nO equipamento\r\nPara os testes de performance de leitura e escrita de arquivos csv e parquet apresentados aqui neste post, foi utilizado um notebook Lenovo, com processador intel core i7-4500U quad-core, , 16Gb de memória RAM e HD com capacidade de 1 Tb.\r\nApache Arrow\r\nA Apache Foundation tem mantido o projeto Arrow, que de acordo com o site do projeto (https://arrow.apache.org/): “A cross-language development platform for in-memory analytics”. De forma geral, poderiamos dizer que o Arrow é uma framework para desenvolver aplicações que processam e transportam grandes conjuntos de dados. O Apache Arrow ajuda a melhorar desempenho de algoritmos analíticos e dá eficiência na movimentação de dados de uma sistema (ou linguagem de programação) para outra.\r\nFelizmente, existe uma biblioteca do Apache Arrow no R, de nome arrow, que dentre várias funcionalidades, fornece funções de fácil utilização, para leitura e escrita de arquivos de diversos formatos, incluindo csv e no formato parquet. Para ter acesso a essas funções, primeiro instale a biblioteca arrow:\r\ninstall.packages(\"arrow\")\r\nCarregando os arquivos csv no ambiente R\r\nCom a biblioteca arrow já devidamente instalada, para ler os microdados do Censo Escolar 2019, que estão no formato csv, e que tem o caracter pipe (|) como separador de colunas, basta utilizar a função read_delim_arrow() da biblioteca arrow:\r\nmatricula_NE <- arrow::read_delim_arrow(\r\n  file = \"./microdados_educacao_basica_2019/DADOS/DOCENTES_CO.CSV\",\r\n  delim = \"|\"\r\n)\r\nA leitura do arquivo DOCENTES_CO.CSV, que possui 892.665 registros e 136 campos, e ocupa em disco algo entorno de 268 Mb, levou 5,37 segundos para ser lido. Segue abaixo algumas estatísticas relacionadas aos datasets do censo escolar disponibilizados pelo INEP, incluindo o tempo de carregamento no ambiente R.\r\nTabela 1. Informações sobre leituras de arquivos do Censo escolar 2019 no formato csv com uso da biblioteca arrow no R.\r\ndataset\r\nregistros\r\ncampos\r\ntamanho (KB)\r\ntempo de leitura (segundos)\r\nDOCENTES_CO\r\n892.665\r\n136\r\n285.874\r\n5,37\r\nDOCENTES_NORDESTE\r\n3.044.057\r\n136\r\n964.596\r\n16,75\r\nDOCENTES_NORTE\r\n1.067.901\r\n136\r\n341.999\r\n6,56\r\nDOCENTES_SUDESTE\r\n4.653.852\r\n136\r\n1.478.987\r\n46,21\r\nDOCENTES_SUL\r\n1.879.896\r\n136\r\n600.905\r\n11,08\r\nESCOLAS\r\n228.521\r\n234\r\n108.590\r\n2,50\r\nGESTOR\r\n187.740\r\n83\r\n41.668\r\n1,61\r\nTURMAS\r\n2.432.438\r\n79\r\n450.988\r\n7,42\r\nMATRICULA_CO\r\n3.945.797\r\n103\r\n975.562\r\n19,04\r\nMATRICULA_NORDESTE\r\n15.304.589\r\n103\r\n3.790.278\r\n1.810,51\r\nMATRICULA_NORTE\r\n5.198.366\r\n103\r\n1.289.161\r\n31,73\r\nMATRICULA_SUDESTE\r\n19.785.845\r\n103\r\n4.803.374\r\n3.103,85\r\nMATRICULA_SUL\r\n6.932.126\r\n103\r\n1.703.439\r\n56,18\r\nSalvando dados em arquivos Parquet com Apache Arrow no R\r\nCom o conjunto de dados já carregado no ambiente R, para gravar este dataframe disponível em memória em um arquivo parquet no disco, passe como argumento x da função write_parquet() o nome do dataframe que deseja salvar, e no argumento sink o diretório e o nome do arquivo parquet:\r\narrow::write_parquet( \r\n  x = matricula_NE,\r\n  sink = \"./microdados_educacao_basica_2019/DADOS/MATRICULA_NORDESTE.parquet\"\r\n)\r\nPor exempplo, para o arquivo MATRICULA_NORDESTE.CSV, O R demorou 1.227,41 segundos para gravar o dataframe em um arquivo parquet no disco, ocupando do disco 323.494 KB. Dado que este conjunto de dados no formato CSV ocupava 3.790.278 KB do disco, houve uma redução significativa do tamanho na ordem de 66,8%.\r\nSegue abaixo algumas estatísticas relacionadas a gravação em disco de dataframe em formato parquet:\r\nTabela 2. Informações sobre escritas de arquivos do Censo escolar 2019 no formato parquet com uso da biblioteca arrow no R.\r\ndataset\r\nregistros\r\ncampos\r\ntamanho do csv (KB)\r\ntamanho do parquet (KB)\r\nCompressão\r\ntempo de gravação (segundos)\r\nDOCENTES_CO\r\n892.665\r\n136\r\n285.874\r\n31.213\r\n89,1%\r\n4,91\r\nDOCENTES_NORDESTE\r\n3.044.057\r\n136\r\n964.596\r\n122.796\r\n87,3%\r\n15,16\r\nDOCENTES_NORTE\r\n1.067.901\r\n136\r\n341.999\r\n41.464\r\n87,9%\r\n5,89\r\nDOCENTES_SUDESTE\r\n4.653.852\r\n136\r\n1.478.987\r\n151.313\r\n89,8%\r\n24,14\r\nDOCENTES_SUL\r\n1.879.896\r\n136\r\n600.905\r\n78.500\r\n86,9%\r\n11,20\r\nESCOLAS\r\n228.521\r\n234\r\n108.590\r\n16.943\r\n84,4%\r\n9,63\r\nGESTOR\r\n187.740\r\n83\r\n41.668\r\n10.341\r\n75,2%\r\n3,39\r\nTURMAS\r\n2.432.438\r\n79\r\n450.988\r\n66.316\r\n85,3%\r\n8,54\r\nMATRICULA_CO\r\n3.945.797\r\n103\r\n975.562\r\n323.494\r\n66,8%\r\n20,43\r\nMATRICULA_NORDESTE\r\n15.304.589\r\n103\r\n3.790.278\r\n916.171\r\n75,8%\r\n255,61\r\nMATRICULA_NORTE\r\n5.198.366\r\n103\r\n1.289.161\r\n315.049\r\n75,6%\r\n17,50\r\nMATRICULA_SUDESTE\r\n19.785.845\r\n103\r\n4.803.374\r\n1.146.767\r\n76,1%\r\n1.389,93\r\nMATRICULA_SUL\r\n6.932.126\r\n103\r\n1.703.439\r\n409.738\r\n75,9%\r\n24,07\r\nLendo arquivos Parquet com Apache Arrow no R\r\nAgora, se deseja ler um arquivo parquet salvo em disco, passe como argumento file da função read_parquet() o diretório e o nome do arquivo parquet:\r\nmatricula_NE_Parquet <- arrow::read_parquet(\r\n  file = \"./microdados_educacao_basica_2019/DADOS/MATRICULA_NORDESTE.parquet\"\r\n)\r\nSegue abaixo algumas estatísticas relacionadas a leituras dos datasets do censo escolar 2019 salvos em formato parquet, comparando com os gravados em csv:\r\nTabela 3. Informações sobre leituras de arquivos do Censo escolar 2019 no formato parquet com uso da biblioteca arrow no R.\r\ndataset\r\nregistros\r\ncampos\r\ntempo de leitura do csv (segundos)\r\ntempo de leitura do parquet (segundos)\r\nTempo de Leitura CSV / Tempo de Leitura Parquet\r\nDOCENTES_CO\r\n892.665\r\n136\r\n5,37\r\n2,87\r\n1,9\r\nDOCENTES_NORDESTE\r\n3.044.057\r\n136\r\n16,75\r\n8,14\r\n2,1\r\nDOCENTES_NORTE\r\n1.067.901\r\n136\r\n6,56\r\n3,79\r\n1,7\r\nDOCENTES_SUDESTE\r\n4.653.852\r\n136\r\n46,21\r\n11,18\r\n4,1\r\nDOCENTES_SUL\r\n1.879.896\r\n136\r\n11,08\r\n6,04\r\n1,8\r\nESCOLAS\r\n228.521\r\n234\r\n2,50\r\n2,11\r\n1,2\r\nGESTOR\r\n187.740\r\n83\r\n1,61\r\n1,51\r\n1,1\r\nTURMAS\r\n2.432.438\r\n79\r\n7,42\r\n6,41\r\n1,2\r\nMATRICULA_CO\r\n3.945.797\r\n103\r\n19,04\r\n14,19\r\n1,3\r\nMATRICULA_NORDESTE\r\n15.304.589\r\n103\r\n1.810,51\r\n63,77\r\n28,4\r\nMATRICULA_NORTE\r\n5.198.366\r\n103\r\n31,73\r\n14,70\r\n2,2\r\nMATRICULA_SUDESTE\r\n19.785.845\r\n103\r\n3.103,85\r\n109,02\r\n28,5\r\nMATRICULA_SUL\r\n6.932.126\r\n103\r\n56,18\r\n16,44\r\n3,4\r\nVale ressaltar que, se for de interesse ler somente algumas colunas do conjunto de dados, ao usar a função read_parquetda biblioteca arrow, basta incluir o argumento col_select e passar para ele um vetor com os nomes das colunas que deseja ler. Esse argumento também suporta as funções auxiliares de seleção de atributos da função selectda biblioteca dplyr como a starts_with(), ends_with(), contains(), matches(), etc.\r\nConsiderações importantes\r\nAo comparar conjuntos de dados identicos salvos em formatos diferentes (csv e parquet), percebe-se (vide tabela 2) que os arquivos parquet consomem muito menos espaços em disco, visto que os arquivos de armazenamento orientados a colunas tem taxa de compressão maiores do que os orientados a linhas. Isso traz uma vantagem imensa em armazenar dados em formatos parquet pois o custo cai significativamente. Pela comparação dos 15 conjuntos de dados do Censo Escolar 2019, verificamos redução média de 81,2% comparando o tamanho de arquivos parquetem relação ao formato csv.\r\nOutro fato que chama atenção é que, mesmo quando se tem conjunto de dados com os mesmo registros e colunas porém salvos em formato diferentes, a leitura de arquivos parquet é mais rápida que de arquivos csv, este último chegando a ter leitura 28 vezes mais demorada, sendo que na maioria das vezes demora em média o dobro do tempo de leitura.\r\nAinda, vale destacar que para tarefas, onde na maioria das vezes não são utilizadas todas as colunas do conjunto de dados para conduzir uma análise, o fato do parquet ser um formato de arquivo orientado a colunas, pode ser lido somente as colunas de interesse, diminuindo assim o tempo de leitura do arquivo, bem como consumindo menos recursos computacional, levando novamente vantagem em relação ao csv que teria que varrer todo o conjunto de dados para depois manter somente as colunas de interesse, resultando em gasto de tempo e de recurso computacional.\r\nBônus - Carregando os arquivos csv no ambiente R com outras bibliotecas\r\nAlém da arrow, que possui a `read_delim_arrow, outras biblioteca também disponibilizam funções para leituras de arquivos csv. O próprio R Base tem a função read.delim() (da biblioteca utils) para ler arquivos no formato de valores separados por caracter, conforme script abaixo:\r\nmatricula_NE <- utils::read.delim(\r\n  file = \"./microdados_educacao_basica_2019/DADOS/DOCENTES_CO.CSV\",\r\n  delim = \"|\"\r\n)\r\nNa biblioteca readr do Tidyverse tem a a função read_delim() para ler arquivos csv:\r\nmatricula_NE <- readr::read_delim(\r\n  file = \"./microdados_educacao_basica_2019/DADOS/DOCENTES_CO.CSV\",\r\n  delim = \"|\"\r\n)\r\nJá a biblioteca data.table oferece a função fread() para ler arquivos csv:\r\nmatricula_NE <- data.table::fread(\r\n  file = \"./microdados_educacao_basica_2019/DADOS/DOCENTES_CO.CSV\",\r\n  sep = \"|\"\r\n)\r\nTabela 4. Tempo de leitura (em segundos) de arquivos do Censo escolar 2019 no formato csv de acordo com algumas biblioteca do R.\r\ndataset\r\narrow\r\nreadr\r\nutils\r\ndata.table\r\nDOCENTES_CO\r\n5,37\r\n17,97\r\n40,13\r\n4,23\r\nDOCENTES_NORDESTE\r\n14,04\r\n53,79\r\n133,05\r\n6,17\r\nDOCENTES_NORTE\r\n6,37\r\n21,31\r\n47,90\r\n2,85\r\nDOCENTES_SUDESTE\r\n33,08\r\n83,83\r\n206,15\r\n9,10\r\nDOCENTES_SUL\r\n7,97\r\n34,14\r\n75,37\r\n4,72\r\nESCOLAS\r\n2,66\r\n9,18\r\n17,53\r\n1,74\r\nGESTOR\r\n1,30\r\n2,72\r\n5,94\r\n0,72\r\nTURMAS\r\n5,45\r\n26,47\r\n64,62\r\n4,28\r\nMATRICULA_CO\r\n16,40\r\n55,61\r\n122,14\r\n9,29\r\nMATRICULA_NORDESTE\r\n1.407,40\r\n-\r\n1.747,50\r\n30,72\r\nMATRICULA_NORTE\r\n23,89\r\n74,22\r\n202,72\r\n12,21\r\nMATRICULA_SUDESTE\r\n3.103,85\r\n-\r\n-\r\n60,73\r\nMATRICULA_SUL\r\n53,30\r\n91,75\r\n250,81\r\n16,06\r\nVale ressaltar que o readr não conseguiu ler os arquivos MATRICULA_NORDESTE e MATRICULA_SUDESTE, justamente os mais massivos, tanto em termos de número de registros, quanto em termos de tamanho em disco. A biblioteca utils, do Base do R, não conseguiu ler o MATRICULA_SUDESTE, o maior conjunto de dados analisado aqui neste post.\r\nVeja o gráfico a seguir (elaborado em ggplot2, claro!) com o tempo de leitura (em segundos) dos microdados do Censo Escolar 2019 em formato csv, realizadas através de funções de quatro bibliotecas diferentes do R. Vale ressaltar que não foram plotados os tempos de leituras dos conjuntos de dados por questões de escala.\r\n\r\nEntre as 4 funções comparadas, a read.delim() da biblioteca utils se destava como a que mais demorou para ler os arquivos nos formatos csv, seguida pela read_delim() do readr. Já a função read_delim_arrow apresentou tempo de leitura próximo a da fread da biblioteca data.table, porém, à medida que o conjunto de dados ia se tornando mais massivo, a performance do arrow diminuia significativamente, enquanto o data.table se manteve robusto em termos de tempo de leitura dos csv.\r\nVeja a seguir comparação somente entre arrow e data.table, porém agora considerando todos os conjuntos de dados:\r\n\r\nEnfim, para este experimento, realizado com os 13 conjuntos de dados do Censo Escolar 2019, o data.table foi o campeão em termos de leitura de conjunto de dados separados por caracteres através da função fread, pois se manteve performático, mesmo quando o conjuntos era bastante massivo.\r\n\r\n\r\n\r\n",
    "preview": "posts/parquet_com_R/parquet.png",
    "last_modified": "2021-02-18T19:21:01-03:00",
    "input_file": {},
    "preview_width": 450,
    "preview_height": 112
  },
  {
    "path": "posts/spark_com_R/",
    "title": "Big Data com Spark e R: primeiros passos",
    "description": "O Spark é um framework da Apache foundation para trabalhar com processamento de big data através de computação distribuida. Atualmente existem duas bibliotecas que permite escrever jobs para o Spark, em linguagem R, a `sparkr` e a `sparklyr`, esta última desenvolvida e mantida pela RStudio. Este post apresenta desde a instalação do Spark até algumas tarefas de manipulação e processamento de dataset no Spark, e o mais legal, tudo direto do RStudio, utilizando linguagem R, através da biblioteca `sparklyr. Os dados do Censo Escolar 2019 foram utilizados como exemplo.",
    "author": [
      {
        "name": "Jonatas Silva do Espirito Santo",
        "url": "https://github.com/jonates/"
      }
    ],
    "date": "2021-02-14",
    "categories": [],
    "contents": "\r\n\r\nbody {\r\ntext-align: justify}\r\n\r\nPreparando o ambiente\r\nAbra o RStudio e instale a biblioteca sparklyr:\r\ninstall.packages(\"sparklyr\")\r\nO Spark exige que tenha o java 8 instalado em seu computador (a partir da versão 3 do Spark, exige versão 8u92 ou superior do JDK - Java™ SE Development Kit 8, Update 92). Se ainda não possui o java instalado, faça o download da versão exigida pelo Spark no site https://www.oracle.com/br/java/technologies/javase/javase-jdk8-downloads.html.\r\nPara verificar se tem o java correto está instalado através do comando:\r\nsystem(\"java -version\")\r\nEm seguida, após garantir que o computador tem o java 8 instalado, utilize o comando a seguir para a instalar o Spark em seu computador:\r\nsparklyr::spark_install()\r\nAgora, verifique se o Spark está instalado, e em qual versão, através do script a seguir:\r\nsparklyr::spark_installed_versions()\r\nConectando o RStudio ao Spark\r\nCom o Spark já está instalado no computador, primeiro deve ser criado uma conexão entre o RStudio e o Spark através da função spark_connect. Vamos utilizar o Spark no modo “standalone”, portanto no argumento masterutilize o termo “local”:\r\nconexao_spark <- sparklyr::spark_connect(master = \"local\")\r\nAgora, vamos utilizar a função spark_connection_is_open para verificar se a conexão com o Spark está ativa. Ao rodar o comando abaixo é espero retorno TRUE:\r\nsparklyr::spark_connection_is_open(sc = conexao_spark)\r\nTambém, é possível monitorar, através de um browser, todos os jobs que estão sendo executados em seu Spark. Basta executar no RStudio o seguinte comando:\r\nsparklyr::spark_web()\r\nCopiando arquivos do ambiente R para o Spark\r\nPara aproveitar todo ferramental do Spark em realizações de tarefas com um conjunto de dados, seja ela de transformação, contagem ou até mesmo de ajuste de um modelo de machine learning, é preciso copiar os dados para o Spark. Se os dados já estiver carregado no ambiente do RStudio, basta utilizar a função copy_to, passando o nome da conexão no argumento dest, o nome do objeto que deseja copiar para o Spark no argumento df e um nome (entre aspas duplas) que deseja atribuir ao objeto dentro do ambiente Spark no argumento name.\r\nPara ilustrar, vamos utilizar os dados do ideb (índice de desenvolvimento da educação básica) das séries iniciais do ensino fundamental de escolas Brasil, que será carregado através do pacote idebr (para instalar a biblioteca idebr execute o comando devtools::install_github(\"jonates/idebr\")):\r\n#carregando o conjuntos de dados no ambiente R\r\n\r\nideb_escolas <- idebr::ideb_fundamental_iniciais_escolas\r\n\r\n#copiando o conjunto de dados para o Spark\r\n\r\nsparklyr::copy_to(\r\n  dest = conexao_spark,\r\n  df = ideb_escolas,\r\n  name = \"ideb_EFSI\"\r\n)\r\nPara verificar, quais tabelas / conjuntos de dados estão disponíveis em seu Spark, use a função src_tbls() da biblioteca dplyrinformando o nome da conexão Spark no argumento x conforme script a seguir:\r\ndplyr::src_tbls(x = conexao_spark)\r\nLendo e escrevendo arquivos em disco com Apache Spark através do R\r\nPorém, suponha agora que seja de interesse que o Spark leia um arquivo csv direto de um diretório. Para isso, basta utilizar a função spark_read_csv da biblioteca sparklyr, sendo que nos argumentos sctem que colocar o nome da conexão, em name o nome que deseja atribuir ao dataset dentro do Spark, em path o diretório e nome do arquivo csv que deseja ler, em charset está associado com a região e resolve problemas de encoding, em delimiter coloca o caractere que separa as colunas do arquivo csv:\r\nDOCENTES_CO <- sparklyr::spark_read_csv(\r\n  sc = conexao_spark,\r\n  name = \"DOCENTES_CO\",\r\n  path = \"./microdados_educacao_basica_2019/DADOS/DOCENTES_CO.CSV\",\r\n  charset = \"Latin1\",\r\n  delimiter = \"|\",\r\n  memory = FALSE\r\n)  \r\n\r\n\r\n\r\n",
    "preview": "posts/spark_com_R/spark_logo.jpg",
    "last_modified": "2021-02-15T23:32:03-03:00",
    "input_file": {}
  },
  {
    "path": "posts/idebr/",
    "title": "Dados do ideb direto do R?",
    "description": "Com o idebr é possível acessar, de forma fácil e leve, dados do índice de desenvolvimento da educação básica, diretamente do R, sem precisar fazer download de nenhum arquivo.",
    "author": [
      {
        "name": "Jonatas Silva do Espirito Santo",
        "url": "https://github.com/jonates/"
      }
    ],
    "date": "2021-01-11",
    "categories": [],
    "contents": "\r\n\r\nbody {\r\ntext-align: justify}\r\nidebr \r\nEste pacote disponibiliza conjuntos de dados, com informações do IDEB - índice de desenvolvimento da educação básica, com as devidas desagregações e estratificações, já no formato tidy, apropriado para geração de visualizações em ggplot2 e que podem serem utilizados em diversas aplicações no R.\r\nAtualmente disponibiliza 6 conjuntos de dados:\r\nideb_fundamental_iniciais_brasil\r\nideb_fundamental_iniciais_escolas\r\nideb_fundamental_finais_brasil\r\nideb_fundamental_finais_escolas\r\nideb_ensino_medio_brasil\r\nideb_ensino_medio_escolas\r\nO ideb_fundamental_iniciais_brasil contem como atributo os valores dos indicadores utilizados para o calculo do IDEB das séries iniciais (1º ao 5º ano) do ensino fundamental para o Brasil, como as taxas de aprovacoes (por serie) e as notas da prova SAEB. Conta tambem com o valor do IDEB e as metas para os anos de 2005, 2007, 2009, 2013, 2015, 2017 e 2019. Tambem estratifica essas informacoes pela rede de ensino.\r\nO ideb_fundamental_iniciais_escolas contem como atributo os valores dos indicadores utilizados para o calculo do IDEB das series iniciais (1º ao 5º ano) do ensino fundamental para as escolas do Brasil, como as taxas de aprovacoes (por serie) e as notas da prova SAEB. Conta tambem com o valor do IDEB e as metas para os anos de 2005, 2007, 2009, 2013, 2015, 2017 e 2019. Tambem estratifica essas informacoes pela rede de ensino.\r\nO ideb_fundamental_finais_brasil contem como atributo os valores dos indicadores utilizados para o calculo do IDEB das séries finais (6º ao 9º ano) do ensino fundamental para o Brasil, como as taxas de aprovacoes (por serie) e as notas da prova SAEB. Conta tambem com o valor do IDEB e as metas para os anos de 2005, 2007, 2009, 2013, 2015, 2017 e 2019. Tambem estratifica essas informacoes pela rede de ensino.\r\nO ideb_fundamental_finais_escolas contem como atributo os valores dos indicadores utilizados para o calculo do IDEB das series finais (6º ao 9º ano) do ensino fundamental para as escolas do Brasil, como as taxas de aprovacoes (por serie) e as notas da prova SAEB. Conta tambem com o valor do IDEB e as metas para os anos de 2005, 2007, 2009, 2013, 2015, 2017 e 2019. Tambem estratifica essas informacoes pela rede de ensino.\r\nO ideb_ensino_medio_brasil contem como atributo os valores dos indicadores utilizados para o calculo do IDEB do ensino medio para o Brasil, como as taxas de aprovacoes (por serie) e as notas da prova SAEB. Conta tambem com o valor do IDEB e as metas para os anos de 2017 e 2019. Tambem estratifica essas informacoes pela rede de ensino.\r\nO ideb_ensino_medio_escolas contem como atributo os valores dos indicadores utilizados para o calculo do IDEB do ensino medio para as escolas do Brasil, como as taxas de aprovacoes (por serie) e as notas da prova SAEB. Conta tambem com o valor do IDEB e as metas para os anos de 2017 e 2019. Tambem estratifica essas informacoes pela rede de ensino.\r\nInstalacao\r\n#Instale o pacote devtoools caso ainda não tenha instalado\r\n#install.packages(devtools)\r\n\r\n#instala o pacote idebr\r\ndevtools::install_github(\"jonates/idebr\")\r\nCarregar conjunto de dados\r\nApos a instalacao do pacote idebr para carregar um conjunto de dados basta digitar no script idebr::nomedodataset. Caso esteja no RStudio, basta digitar ideb:: e apertar a tecla tab que o autocompletar do RStudio vai mostrar todos os conjuntos de dados disponiveis no pacote idebr para que voce possa escolher, conforme imagem abaixo:\r\n\r\nExemplo 1\r\n#carrega a base do ideb do ensino médio do Brasil\r\ndf <- idebr::ideb_ensino_medio_brasil\r\n\r\n#Plot o gráfico do IDEB do Brasil, por ano e por rede de ensino.\r\nlibrary(ggplot2)\r\nggplot(data = df) +\r\n  geom_point(aes(x=ano,y=ideb,colour=rede))\r\n\r\n\r\nRoadmap\r\nEstrato\r\nFundamental - iniciais\r\nFundamental - finais\r\nEnsino Medio\r\nBrasil\r\nOk\r\nOk\r\nOk\r\nRegioes\r\n-\r\n-\r\n-\r\nUF\r\n-\r\n-\r\n-\r\nMunicipios\r\n-\r\n-\r\n-\r\nEscolas\r\nOk\r\nOk\r\nOk\r\n\r\n\r\n\r\n",
    "preview": "posts/idebr/idebr.jpeg",
    "last_modified": "2021-02-05T23:27:56-03:00",
    "input_file": {}
  },
  {
    "path": "posts/contribua/",
    "title": "Envie seu artigo",
    "description": "Contribua com artigos para o Blog.",
    "author": [
      {
        "name": "SEIDataLab",
        "url": "https://github.com/SEIDataLab"
      }
    ],
    "date": "2021-01-08",
    "categories": [],
    "contents": "\r\n\r\nbody {text-align: justify}\r\nNosso objetivo é divulgar trabalhos e pesquisas no âmbito da Ciência de Dados e dados públicos. Sabemos que a comunidade dos dados é bastante ativa e colaborativa, neste sentido abrimos este espaço para que a comunidade possa contibuir enviando seus artigos. Adoraríamos publicar o seu artigo por aqui!\r\nO contato para envio dos artigos pode ser feito por meio do endereço de email seidatalab@sei.ba.gov.br\r\nComo este blog é totalmente construído em Distill for Markdown, apreciamos artigos que sejam enviados no formato R Markdown. Para dicas em como escrever o artigo em R Markdown sugerimos o cheat sheet da RStudio\r\nMetadados\r\nAlgumas informações sobre metadados são necessárias para a publicação de artigos no blog. Deixamos a seguir um exemplo com os metadados necessários para a publicação no blog:\r\n\r\n---\r\ntitle: \"Título do Artigo\"\r\ndescription: |\r\n  Subtítulo: Breve descrição sobre o artigo.\r\nauthor:\r\n  - name: Nome e Sobrenome do autor \r\n    url: url de endereço do autor (exemplo: linkedin, github ou site pessoal)\r\n    affiliation: vinculação institucional do autor\r\n    affiliation_url: url de endereço da vinculação autor (se houver)\r\ndate: mm-dd-yyyy # data da publicação\r\ncreative_commons: CC BY #licença creative commons\r\nrepository_url: link do repositório (github) do código (se houver)\r\noutput: \r\n  distill::distill_article:\r\n    self_contained: false\r\n---\r\n\r\nNo campo author devem ser colocadas as características do autor ou autores (podem ser incluídos vários autores), bem como sua afiliação. Observe também o campo da licença creative_commons, que marca o artigo como podendo ser compartilhado (todos os posts enviados devem ter uma licença Creative Commons possibilitando o compartilhamento). Finalmente, o repository_url é usado para fornecer links do artigo, base de dados ou códigos hospodados no GitHub.\r\nEstamos aguardando para publicar o seu artigo!\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-01-31T10:56:08-03:00",
    "input_file": {}
  },
  {
    "path": "posts/sobre_o_seidatalab/",
    "title": "Sobre o SeiDataLab",
    "description": "O que é o SEIDataLab?",
    "author": [
      {
        "name": "Rodrigo Cerqueira",
        "url": "https://www.linkedin.com/in/rodrigobcerqueira/"
      }
    ],
    "date": "2021-01-07",
    "categories": [],
    "contents": "\r\n\r\nbody {text-align: justify}\r\nO SEIDataLab é o laboratório de dados da Superintendência de Estudos Econômicos e Sociais da Bahia (SEI), focado em análise de dados e geração de insights, auxiliando decisões de políticas públicas estaduais.\r\nCriado em 2019, como um desdobramento do Grupo de Trabalho (GT) de Business Intelligence, Big Data e Ciência de Dados, publicado na Portaria nº 18 de 05 de setembro de 2019, o SEIDataLab surgiu, a partir da percepção da área técnica de diferentes Coordenações e Diretorias da SEI, acerca das necessidade de sistematizar conceitos, técnicas e procedimentos em Ciência de Dados e atividades correlatas no âmbito da Superintendência.\r\nO objetivo do laboratório é colocar a SEI na vanguarda da geração de insights para a formulação de políticas públicas orientadas a dados e avançar a inserção cada vez maior do Estadao da Bahia na era do Governo 4.0 e gestão pública orientada a dados.\r\nAtualmente o laboratório construiu e administra o primeiro Data Lake, integrado a um Cluster de Processamento Paralelo de grandes bases de dados do Governo do Estado, construído com o que há de mais moderno no atual cenário das ferramentas de Big Data, como Apache Spark, Apache Ranger e Presto.\r\n\r\n\r\n\r\n",
    "preview": "posts/sobre_o_seidatalab/SeiDataLab.png",
    "last_modified": "2021-01-31T10:56:08-03:00",
    "input_file": {},
    "preview_width": 743,
    "preview_height": 292
  }
]
